\documentclass{article}

\usepackage{fancyvrb}
\usepackage{mathpartir}
\usepackage{mathtools}

\DefineVerbatimEnvironment{verbatim}{Verbatim}{xleftmargin=.5in}

\author{
  Reinier Maas \\ 4131495
  \and
  Adolfo OchagavÃ­a \\ 4045483
}
\title{CCO - Assignment 3}
\begin{document}

\maketitle

\section{Building and testing}

Provided you have \texttt{stack} installed on your system, you can use \texttt{stack build} to build the project and \texttt{stack test} to test it.
The project is implemented as a library, so there is no executable. You can test things manually through GHCi (see \texttt{FunFlow.Lib.run}), or just rely on \texttt{stack test}.
The project should probably build as well when using \texttt{cabal}, though we haven't tested it.

For each file in the \texttt{examples} directory, there is a line in \texttt{test/Spec.hs} that indicates which type is expected. When running the tests, files are type checked to see whether the result of algorithm W matches the expected type. Besides this information, each test outputs the internal representation of the AST and the constraints generated by the control-flow analysis.

In order to illustrate the results produced by our tests, let us consider the output when testing \texttt{examples/if\_fn}. This file contains the following expression:

\begin{verbatim}
if true then (fn x => x) else (fn y => y + 1)
\end{verbatim}

The output of our test suite is:

\begin{verbatim}
Passed (if_fn) with type Int 5-> Int
=> ast: ITE (Bool True) (Fn 0 "x" (Var "x")) (Fn 1 "y"
(Oper Add (Var "y") (Int 1)))
=> constraints: [(5,[0,1])]
\end{verbatim}

Here, \texttt{Int 5-> Int} is the type of the expression. The $5$ before the arrow is the annotation variable corresponding to the function. In the constraints, we can see that the annotation variable is associated to $0$ and $1$. This means that the returned function comes from one of the branches of the if. You can check this by looking at the AST, where the functions have a $\pi$ of $0$ and $1$.

\section{Type rules}

\subsection{Introducing the Tuple type}

Since we are adding lists (part iii) and tuples (parts ii and iv) to the language, we need to introduce at least a new type to represent these constructs.

\[\hat{\tau} ::= \alpha\ |\ Nat\ |\ Bool\ |\ \hat{\tau} \overset{\varphi}{\rightarrow} \hat{\tau}\ |\ Tuple_\varphi\ [\hat{\tau}] \]

As you can see, there is a new type called \texttt{Tuple} (represented by \texttt{TypeTuple} in \texttt{TypeSystem.hs}).
It contains an annotation variable and a list of types.
We use this type to represent lists and tuples (including pairs).
Having just one representation is useful because it results in only one extra case to handle in our implementation of unification, type substitution and instantiation.

\subsection{Type rules}

\[
\inferrule[Pair]{\hat{\Gamma} \vdash_{CFA} e_1 : \hat{\tau}_1 \quad \hat{\Gamma} \vdash_{CFA} e_2 : \hat{\tau}_2}
{\hat{\Gamma} \vdash_{CFA} Pair_\pi(e_1, e_2) : Tuple_\pi\ [\hat{\tau}_1, \hat{\tau}_2]}
\]

\bigskip

\[
\inferrule[PCase]
{\hat{\Gamma} \vdash_{CFA} e_0 : Tuple_\varphi\ [\hat{\tau}_1, \hat{\tau}_2] \quad \hat{\Gamma}[x_1 \mapsto \hat{\tau}_1][x_2 \mapsto \hat{\tau}_2] \vdash_{CFA} e_1 : \hat{\tau}_3}
{\hat{\Gamma} \vdash_{CFA} pcase\ e_0\ of\ Pair(x_1, x_2) => e_1 : \hat{\tau}_3}
\]

\bigskip
\[
\inferrule[Cons]
{\hat{\Gamma} \vdash_{CFA} e_1 : \hat{\tau} \quad \hat{\Gamma} \vdash_{CFA} e_2 : \hat{\tau}}
{\hat{\Gamma} \vdash_{CFA} Cons_\pi(e_1, e_2) : Tuple_\pi\ [\hat{\tau}] }
\]

\bigskip

\[
\inferrule[Nil]{\ }{\hat{\Gamma} \vdash_{CFA} Nil_\pi : Tuple_\pi\ [\hat{\tau}]}
\]

\bigskip

\[
\inferrule[LCase]
{\hat{\Gamma} \vdash_{CFA} e_0 : Tuple_\varphi\ [\hat{\tau}_1] \quad \hat{\Gamma}[x_1 \mapsto \hat{\tau}_1][x_2 \mapsto \hat{\tau}_1] \vdash_{CFA} e_1 : \hat{\tau}_2 \quad \hat{\Gamma} \vdash_{CFA} e_2 : \hat{\tau}_2}
{\hat{\Gamma} \vdash_{CFA} lcase\ e_0\ of\ Cons(x_1, x_2) => e_1\ or\ e_2 : \hat{\tau}}
\]

\bigskip

\[
\inferrule[C]
{\hat{\Gamma} \vdash_{CFA} e_1 : \hat{\tau}_1 \quad \ldots \quad \hat{\Gamma} \vdash_{CFA} e_n : \hat{\tau}_n}
{\hat{\Gamma} \vdash_{CFA} C_\pi(e_1,\ \ldots\ , e_n) : Tuple_\pi\ [\hat{\tau}_1,\ \ldots\ , \hat{\tau}_n]}
\]

\bigskip

\[
\inferrule[Case]
{\hat{\Gamma} \vdash_{CFA} e_0 : Tuple_\varphi\ [\hat{\tau}_1,\ \ldots\ , \hat{\tau}_n] \quad \hat{\Gamma}[x_1 \mapsto \hat{\tau}_1][\ldots][x_n \mapsto \hat{\tau}_n] \vdash_{CFA} e_1 : \hat{\tau}_0 \quad \hat{\Gamma} \vdash_{CFA} e_2 : \hat{\tau}_0}
{\hat{\Gamma} \vdash_{CFA} case\ e_0\ of\ C(x_1,\ \ldots\ , x_n) => e_1\ or\ e_2 : \hat{\tau}_0}
\]

\end{document}
