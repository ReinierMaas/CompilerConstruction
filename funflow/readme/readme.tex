\documentclass{article}

\usepackage{fancyvrb}
\usepackage{mathpartir}
\usepackage{mathtools}

\DefineVerbatimEnvironment{verbatim}{Verbatim}{xleftmargin=.5in}

\author{
  Reinier Maas \\ 4131495
  \and
  Adolfo OchagavÃ­a \\ 4045483
}
\title{CCO - Assignment 3}
\begin{document}

\maketitle

\section{Building and testing}

Provided you have \texttt{stack} installed on your system, you can use \texttt{stack build} to build the project and \texttt{stack test} to test it.
The project is implemented as a library, so there is no executable. You can test things manually through GHCi (see \texttt{FunFlow.Lib.run}), or just rely on \texttt{stack test}.
The project should probably build as well when using \texttt{cabal}, though we haven't tested it.

For each file in the \texttt{examples} directory, there is a line in \texttt{test/Spec.hs} that indicates which type is expected. When running the tests, files are type checked to see whether the result of algorithm W matches the expected type. Besides this information, each test outputs the internal representation of the AST and the constraints generated by the control-flow analysis.

In order to illustrate the results produced by our tests, let us consider the output when testing \texttt{examples/if\_fn}. The expression is shown below:

\begin{verbatim}
if true then (fn x => x) else (fn y => y + 1)
\end{verbatim}

The output of our test suite is:

\begin{verbatim}
Passed (if_fn) with type Int 5-> Int
=> ast: ITE (Bool True) (Fn 0 "x" (Var "x")) (Fn 1 "y"
(Oper Add (Var "y") (Int 1)))
=> constraints: [(5,[0,1])]
\end{verbatim}

Here, \texttt{Int 5-> Int} is the type of the expression. The $5$ before the arrow is the annotation variable corresponding to the function. In the constraints, we can see that the annotation variable is associated to $0$ and $1$. This means that the returned function comes from one of the branches of the if. You can check this by looking at the AST, where the functions have a pi of $0$ and $1$.

\section{Type rules}

\subsection{Introducing a Tuple type}

Since we are adding lists (part iii) and tuples (parts ii and iv) to the language, we need to introduce at least a new type to represent these constructs.

\[\hat{\tau} ::= \alpha\ |\ Nat\ |\ Bool\ |\ \hat{\tau} \overset{\varphi}{\rightarrow} \hat{\tau}\ |\ Tuple_\varphi\ [\hat{\tau}] \]

As you can see, there is a new type called \texttt{Tuple} (represented by \texttt{TypeTuple} in \texttt{TypeSystem.hs}).
It contains an annotation variable and a list of types.
We use this type to represent lists and tuples (including pairs).
Having just one representation is useful because it results in less type rules [FIXME: does it?].

\subsection{Type rules}

In the case of tuples, there is a $\hat{\tau}$ for each component.
In the case of lists, there is only one $\hat{\tau}$, since all elements in the list should have the same type.

We inherit all type rules defined in the slides of the course.

Pairs

\[
\inferrule[Pair]{\hat{\Gamma} \vdash_{CFA}}{program\ P\ in\ L : Program\ L}
\]

\[
\inferrule[PCase]
{\hat{\Gamma} \vdash_{CFA} e_0 : Tuple_\varphi\ [t_1, t_2] \quad \hat{\Gamma}[x_1 \mapsto t_1][x_2 \mapsto t_2] \vdash_{CFA} e_1 : \hat{\tau}}
{\hat{\Gamma} \vdash_{CFA} pcase\ e_0\ of\ Pair(x_1, x_2) => e_1 : \hat{\tau}}
\]

\[
\inferrule[Cons]{a}{b}
\]

\[
\inferrule[Nil]{a}{b}
\]

\[
\inferrule[LCase]
{\hat{\Gamma} \vdash_{CFA} e_0 : Tuple_\varphi\ [t] \quad \hat{\Gamma}[x_1 \mapsto t][x_2 \mapsto t] \vdash_{CFA} e_1 : \hat{\tau} \quad \hat{\Gamma} \vdash_{CFA} e_2 : \hat{\tau}}
{\hat{\Gamma} \vdash_{CFA} lcase\ e_0\ of\ Cons(x_1, x_2) => e_1\ or\ e_2 : \hat{\tau}}
\]

\[
\inferrule[C]{a}{b}
\]

\[
\inferrule[Case]
{\hat{\Gamma} \vdash_{CFA} e_0 : Tuple_\varphi\ [t_1,\ \ldots\ , t_n] \quad \hat{\Gamma}[x_1 \mapsto t_1][\ldots][x_n \mapsto t_n] \vdash_{CFA} e_1 : \hat{\tau} \quad \hat{\Gamma} \vdash_{CFA} e_2 : \hat{\tau}}
{\hat{\Gamma} \vdash_{CFA} case\ e_0\ of\ C(x_1,\ \ldots\ , x_n) => e_1\ or\ e_2 : \hat{\tau}}
\]

\end{document}
